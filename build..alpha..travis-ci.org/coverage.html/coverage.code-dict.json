{"/home/travis/build/npmtest/node-npmtest-datapumps/test.js":"/* istanbul instrument in package npmtest_datapumps */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-datapumps/lib.npmtest_datapumps.js":"/* istanbul instrument in package npmtest_datapumps */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_datapumps = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_datapumps = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-datapumps/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-datapumps && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_datapumps */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_datapumps\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_datapumps.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_datapumps.rollup.js'] =\n            local.assetsDict['/assets.npmtest_datapumps.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_datapumps.__dirname + '/lib.npmtest_datapumps.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/index.js":"var Group = require('./lib/Group');\n\nmodule.exports = {\n  Buffer: require('./lib/Buffer'),\n  Pump: require('./lib/Pump'),\n  PumpingFailedError: require('./lib/PumpingFailedError'),\n  Group: Group,\n  group: function() { return new Group(); },\n  mixin: require('./lib/mixin')\n}\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/Group.js":"(function() {\n  var Buffer, Group, Promise, Pump, PumpingFailedError,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __slice = [].slice;\n\n  Promise = require('bluebird');\n\n  Pump = require('./Pump');\n\n  PumpingFailedError = require('./PumpingFailedError');\n\n  Buffer = require('./Buffer');\n\n  module.exports = Group = (function(_super) {\n    __extends(Group, _super);\n\n    function Group() {\n      Group.__super__.constructor.call(this);\n      this._pumps = {};\n      this._exposedBuffers = {};\n    }\n\n    Group.prototype.addPump = function(name, pump) {\n      var pumpId;\n      if (pump == null) {\n        pump = null;\n      }\n      if (this._pumps[name] != null) {\n        throw new Error('Pump already exists');\n      }\n      this._pumps[name] = pump != null ? pump : new Pump;\n      pumpId = this._id != null ? \"\" + this._id + \"/\" + name : name;\n      this._pumps[name].id(pumpId);\n      this._pumps[name].errorBuffer(this._errorBuffer);\n      return this._pumps[name];\n    };\n\n    Group.prototype.pump = function(name) {\n      if (this._pumps[name] == null) {\n        throw new Error(\"Pump \" + name + \" does not exist\");\n      }\n      return this._pumps[name];\n    };\n\n    Group.prototype.pumps = function() {\n      return this._pumps;\n    };\n\n    Group.prototype.start = function() {\n      var name, pump, _ref;\n      if (this._state !== Group.STOPPED) {\n        throw new Error('Group already started');\n      }\n      this._state = Group.STARTED;\n      this._registerErrorBufferEvents();\n      _ref = this._pumps;\n      for (name in _ref) {\n        pump = _ref[name];\n        pump.errorBuffer(this._errorBuffer);\n        pump.debugMode(this._debug);\n      }\n      this.run().then((function(_this) {\n        return function() {\n          return _this._endGroup();\n        };\n      })(this))[\"catch\"](function(PumpingFailedError, e) {});\n      return this;\n    };\n\n    Group.prototype._endGroup = function() {\n      this._state = Group.ENDED;\n      return this.emit('end');\n    };\n\n    Group.prototype.run = function() {\n      var result;\n      (result = this.runPumps())[\"catch\"](function(PumpingFailedError, e) {});\n      return result;\n    };\n\n    Group.prototype.runPumps = function(pumps) {\n      var finishPromises, pumpName, _i, _len;\n      if (pumps == null) {\n        pumps = null;\n      }\n      if (pumps == null) {\n        pumps = this._getAllStoppedPumps();\n      }\n      if (typeof pumps === 'string') {\n        pumps = [pumps];\n      }\n      finishPromises = [];\n      for (_i = 0, _len = pumps.length; _i < _len; _i++) {\n        pumpName = pumps[_i];\n        finishPromises.push(this.pump(pumpName).start().whenFinished());\n      }\n      return Promise.all(finishPromises);\n    };\n\n    Group.prototype._getAllStoppedPumps = function() {\n      var name, pump, result, _ref;\n      result = [];\n      _ref = this._pumps;\n      for (name in _ref) {\n        pump = _ref[name];\n        if (pump.isStopped()) {\n          result.push(name);\n        }\n      }\n      return result;\n    };\n\n    Group.prototype.expose = function(exposedName, bufferPath) {\n      if (this._exposedBuffers[exposedName] != null) {\n        throw new Error(\"Already exposed a buffer with name \" + exposedName);\n      }\n      return this._exposedBuffers[exposedName] = this._getBufferByPath(bufferPath);\n    };\n\n    Group.prototype._getBufferByPath = function(bufferPath) {\n      var bufferName, bufferNames, pumpName, _ref;\n      _ref = bufferPath.split('/'), pumpName = _ref[0], bufferNames = 2 <= _ref.length ? __slice.call(_ref, 1) : [];\n      bufferName = bufferNames.length ? bufferNames.join('/') : 'output';\n      return this.pump(pumpName).buffer(bufferName);\n    };\n\n    Group.prototype.buffer = function(name) {\n      var result, _ref;\n      if (name == null) {\n        name = 'output';\n      }\n      try {\n        result = (_ref = this._exposedBuffers[name]) != null ? _ref : this._getBufferByPath(name);\n      } catch (_error) {\n\n      }\n      if (!result) {\n        throw new Error(\"No such buffer: \" + name);\n      }\n      return result;\n    };\n\n    Group.prototype.inputPump = function(pumpName) {\n      if (pumpName == null) {\n        pumpName = null;\n      }\n      if (pumpName == null) {\n        return this._inputPump;\n      }\n      this._inputPump = this.pump(pumpName);\n      return this;\n    };\n\n    Group.prototype.addInputPump = function(name, pump) {\n      var result;\n      if (pump == null) {\n        pump = null;\n      }\n      result = this.addPump(name, pump);\n      this.inputPump(name);\n      return result;\n    };\n\n    Group.prototype.from = function(buffer) {\n      if (buffer == null) {\n        buffer = null;\n      }\n      if (this._inputPump == null) {\n        throw new Error('Input pump is not set, use .inputPump to set it');\n      }\n      this._inputPump.from(buffer);\n      return this;\n    };\n\n    Group.prototype.mixin = function(mixins) {\n      if (this._inputPump == null) {\n        throw new Error('Input pump is not set, use .inputPump to set it');\n      }\n      this._inputPump.mixin(mixins);\n      return this;\n    };\n\n    Group.prototype.process = function() {\n      throw new Error('Cannot call .process() on a group: data in a group is transformed by its pumps.');\n    };\n\n    Group.prototype.pause = function() {\n      var name, pausePromises, pump, _ref;\n      if (this._state === Group.PAUSED) {\n        return;\n      }\n      if (this._state !== Group.STARTED) {\n        throw new Error('Cannot .pause() a group that is not pumping');\n      }\n      pausePromises = [];\n      _ref = this._pumps;\n      for (name in _ref) {\n        pump = _ref[name];\n        if (pump.isStarted()) {\n          pausePromises.push(pump.pause());\n        }\n      }\n      return Promise.all(pausePromises).then((function(_this) {\n        return function() {\n          return _this._state = Group.PAUSED;\n        };\n      })(this));\n    };\n\n    Group.prototype.resume = function() {\n      var name, pump, _ref;\n      if (this._state !== Group.PAUSED) {\n        throw new Error('Cannot .resume() a group that is not paused');\n      }\n      this._state = Group.STARTED;\n      _ref = this._pumps;\n      for (name in _ref) {\n        pump = _ref[name];\n        pump.resume();\n      }\n      return this;\n    };\n\n    Group.prototype.abort = function() {\n      var name, pump;\n      if (this._state !== Pump.STARTED) {\n        throw new Error('Cannot .abort() a group that is not running');\n      }\n      return Promise.all((function() {\n        var _ref, _results;\n        _ref = this._pumps;\n        _results = [];\n        for (name in _ref) {\n          pump = _ref[name];\n          if (pump.isStarted()) {\n            _results.push(pump.abort());\n          }\n        }\n        return _results;\n      }).call(this)).then((function(_this) {\n        return function() {\n          return _this._state = Group.ABORTED;\n        };\n      })(this));\n    };\n\n    Group.prototype.id = function(id) {\n      var name, pump, _ref;\n      if (id == null) {\n        id = null;\n      }\n      if (id === null) {\n        return this._id;\n      }\n      this._id = id;\n      _ref = this._pumps;\n      for (name in _ref) {\n        pump = _ref[name];\n        pump.id(\"\" + this._id + \"/\" + name);\n      }\n      return this;\n    };\n\n    Group.prototype.debugMode = function(_debug) {\n      this._debug = _debug;\n      if (this._state !== Pump.STOPPED) {\n        throw new Error('Cannot change debug mode after pump start');\n      }\n      return this;\n    };\n\n    return Group;\n\n  })(Pump);\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/Pump.js":"(function() {\n  var Buffer, BufferDebugMixin, EventEmitter, Promise, Pump, PumpingFailedError,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  EventEmitter = require('events').EventEmitter;\n\n  Promise = require('bluebird');\n\n  Buffer = require('./Buffer');\n\n  PumpingFailedError = require('./PumpingFailedError');\n\n  BufferDebugMixin = require('./mixin/BufferDebugMixin');\n\n  module.exports = Pump = (function(_super) {\n    __extends(Pump, _super);\n\n    Pump.STOPPED = 0;\n\n    Pump.STARTED = 1;\n\n    Pump.PAUSED = 2;\n\n    Pump.ENDED = 3;\n\n    Pump.ABORTED = 4;\n\n    function Pump() {\n      this._state = Pump.STOPPED;\n      this._from = null;\n      this._id = null;\n      this._errorBuffer = new Buffer;\n      this._debug = false;\n      this.buffers({\n        output: new Buffer\n      });\n    }\n\n    Pump.prototype.id = function(id) {\n      if (id == null) {\n        id = null;\n      }\n      if (id === null) {\n        return this._id;\n      }\n      this._id = id;\n      return this;\n    };\n\n    Pump.prototype.from = function(buffer) {\n      if (buffer == null) {\n        buffer = null;\n      }\n      if (buffer === null) {\n        return this._from;\n      }\n      if (this._state === Pump.STARTED) {\n        throw new Error('Cannot change source buffer after pumping has been started');\n      }\n      if (buffer instanceof Buffer) {\n        this._from = buffer;\n      } else if (buffer instanceof Pump) {\n        this._from = buffer.buffer();\n      } else if (buffer instanceof require('stream')) {\n        this._from = new Buffer({\n          size: 1000\n        });\n        buffer.on('data', (function(_this) {\n          return function(data) {\n            return _this._from.write(data);\n          };\n        })(this));\n        buffer.on('end', (function(_this) {\n          return function() {\n            return _this._from.seal();\n          };\n        })(this));\n        buffer.on('error', (function(_this) {\n          return function(err) {\n            return _this.writeError(err);\n          };\n        })(this));\n        this._from.on('full', function() {\n          return buffer.pause();\n        });\n        this._from.on('release', function() {\n          return buffer.resume();\n        });\n      } else if (buffer instanceof Array) {\n        this._from = new Buffer({\n          content: buffer.slice(0),\n          sealed: true\n        });\n      } else {\n        throw new Error('Argument must be datapumps.Buffer or stream');\n      }\n      this._from.on('end', (function(_this) {\n        return function() {\n          return _this.sourceEnded();\n        };\n      })(this));\n      return this;\n    };\n\n    Pump.prototype.writeError = function(err) {\n      if (this._errorBuffer.isFull()) {\n        return;\n      }\n      this._errorBuffer.write({\n        error: err,\n        pump: this._id\n      });\n      return this;\n    };\n\n    Pump.prototype.sourceEnded = function() {\n      if (this.currentRead) {\n        return this.currentRead.cancel();\n      }\n    };\n\n    Pump.prototype.buffers = function(buffers) {\n      if (buffers == null) {\n        buffers = null;\n      }\n      if (buffers === null) {\n        return this._buffers;\n      }\n      if (this._state === Pump.STARTED) {\n        throw new Error('Cannot change output buffers after pumping has been started');\n      }\n      this._buffers = buffers;\n      return this;\n    };\n\n    Pump.prototype.buffer = function(name, buffer) {\n      if (name == null) {\n        name = 'output';\n      }\n      if (buffer == null) {\n        buffer = null;\n      }\n      if (buffer === null) {\n        if (!this._buffers[name]) {\n          throw new Error(\"No such buffer: \" + name);\n        }\n        return this._buffers[name];\n      } else {\n        if (this._state === Pump.STARTED) {\n          throw new Error('Cannot change output buffers after pumping has been started');\n        }\n        if (!(buffer instanceof Buffer)) {\n          throw new Error('buffer must be a datapumps.Buffer');\n        }\n        this._buffers[name] = buffer;\n        return this;\n      }\n    };\n\n    Pump.prototype.to = function(pump, bufferName) {\n      pump.from(this.buffer(bufferName));\n      return this;\n    };\n\n    Pump.prototype.start = function() {\n      var buffer, name, _ref, _ref1;\n      if (!this._from) {\n        throw new Error('Source is not configured');\n      }\n      if (this._state !== Pump.STOPPED) {\n        throw new Error('Pump is already started');\n      }\n      if (this._debug) {\n        console.log(\"\" + ((new Date()).toISOString()) + \" [\" + ((_ref = this._id) != null ? _ref : '(root)') + \"] Pump started\");\n      }\n      this._state = Pump.STARTED;\n      this._registerErrorBufferEvents();\n      _ref1 = this._buffers;\n      for (name in _ref1) {\n        buffer = _ref1[name];\n        buffer.on('end', this._outputBufferEnded.bind(this));\n      }\n      this._pump();\n      return this;\n    };\n\n    Pump.prototype._registerErrorBufferEvents = function() {\n      return this._errorBuffer.on('full', (function(_this) {\n        return function() {\n          if (_this._state === Pump.STARTED) {\n            return _this.abort().then(function() {\n              return _this.emit('error');\n            });\n          }\n        };\n      })(this));\n    };\n\n    Pump.prototype.abort = function() {\n      var _ref;\n      if (this._state === Pump.ABORTED) {\n        return;\n      }\n      if (this._state !== Pump.STARTED) {\n        throw new Error('Cannot .abort() a pump that is not running');\n      }\n      this._state = Pump.ABORTED;\n      if ((_ref = this._processing) != null ? _ref.isPending() : void 0) {\n        return this._processing.cancel()[\"catch\"](function(err) {});\n      } else {\n        return Promise.resolve();\n      }\n    };\n\n    Pump.prototype._outputBufferEnded = function() {\n      var allEnded, buffer, name, _ref, _ref1;\n      allEnded = true;\n      _ref = this._buffers;\n      for (name in _ref) {\n        buffer = _ref[name];\n        if (!buffer.isEnded()) {\n          allEnded = false;\n        }\n      }\n      if (!allEnded) {\n        return;\n      }\n      this._state = Pump.ENDED;\n      if (this._debug) {\n        console.log(\"\" + ((new Date()).toISOString()) + \" [\" + ((_ref1 = this._id) != null ? _ref1 : '(root)') + \"] Pump ended\");\n      }\n      return this.emit('end');\n    };\n\n    Pump.prototype._pump = function() {\n      if (this._from.isEnded()) {\n        return this.sealOutputBuffers();\n      }\n      if (this._state === Pump.PAUSED || this._state === Pump.ABORTED) {\n        return;\n      }\n      return (this.currentRead = this._from.readAsync()).cancellable().then((function(_this) {\n        return function(data) {\n          var _ref;\n          _this.currentRead = null;\n          _this._processing = _this._process(data, _this);\n          if (!(((_ref = _this._processing) != null ? _ref.then : void 0) instanceof Function)) {\n            _this._processing = void 0;\n            throw new Error(\".process() did not return a Promise\");\n          }\n          _this._processing = Promise.resolve(_this._processing);\n          return _this._processing.cancellable();\n        };\n      })(this))[\"catch\"](Promise.CancellationError, function() {})[\"catch\"]((function(_this) {\n        return function(err) {\n          return _this.writeError(err);\n        };\n      })(this)).done((function(_this) {\n        return function() {\n          return _this._pump();\n        };\n      })(this));\n    };\n\n    Pump.prototype.sealOutputBuffers = function() {\n      var buffer, name, _ref, _results;\n      _ref = this._buffers;\n      _results = [];\n      for (name in _ref) {\n        buffer = _ref[name];\n        if (!buffer.isSealed()) {\n          _results.push(buffer.seal());\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Pump.prototype._process = function(data) {\n      return this.copy(data);\n    };\n\n    Pump.prototype.copy = function(data, buffers) {\n      var buffer;\n      if (buffers == null) {\n        buffers = null;\n      }\n      if (buffers == null) {\n        buffers = ['output'];\n      }\n      if (typeof buffers === 'string') {\n        buffers = [buffers];\n      }\n      if (!Array.isArray(buffers)) {\n        throw new Error('buffers must be an array of buffer names or a single buffers name');\n      }\n      if (buffers.length === 1) {\n        return this.buffer(buffers[0]).writeAsync(data);\n      } else {\n        return Promise.all((function() {\n          var _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = buffers.length; _i < _len; _i++) {\n            buffer = buffers[_i];\n            _results.push(this.buffer(buffer).writeAsync(data));\n          }\n          return _results;\n        }).call(this));\n      }\n    };\n\n    Pump.prototype.process = function(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error('.process() argument must be a Promise returning function ');\n      }\n      this._process = fn;\n      return this;\n    };\n\n    Pump.prototype.mixin = function(mixins) {\n      var mixin, _i, _len;\n      mixins = Array.isArray(mixins) ? mixins : [mixins];\n      for (_i = 0, _len = mixins.length; _i < _len; _i++) {\n        mixin = mixins[_i];\n        mixin(this);\n      }\n      return this;\n    };\n\n    Pump.prototype.isStopped = function() {\n      return this._state === Pump.STOPPED;\n    };\n\n    Pump.prototype.isStarted = function() {\n      return this._state === Pump.STARTED;\n    };\n\n    Pump.prototype.isPaused = function() {\n      return this._state === Pump.PAUSED;\n    };\n\n    Pump.prototype.isEnded = function() {\n      return this._state === Pump.ENDED;\n    };\n\n    Pump.prototype.createBuffer = function(options) {\n      if (options == null) {\n        options = {};\n      }\n      return new Buffer(options);\n    };\n\n    Pump.prototype.errorBuffer = function(buffer) {\n      if (buffer == null) {\n        buffer = null;\n      }\n      if (buffer === null) {\n        return this._errorBuffer;\n      }\n      this._errorBuffer = buffer;\n      return this;\n    };\n\n    Pump.prototype.pause = function() {\n      var _ref;\n      if (this._state === Pump.PAUSED) {\n        return;\n      }\n      if (this._state !== Pump.STARTED) {\n        throw new Error('Cannot .pause() a pump that is not running');\n      }\n      if ((_ref = this._processing) != null ? _ref.isPending() : void 0) {\n        return this._processing.then((function(_this) {\n          return function() {\n            return _this._state = Pump.PAUSED;\n          };\n        })(this));\n      } else {\n        this._state = Pump.PAUSED;\n        return Promise.resolve();\n      }\n    };\n\n    Pump.prototype.resume = function() {\n      if (this._state !== Pump.PAUSED) {\n        throw new Error('Cannot .resume() a pump that is not paused');\n      }\n      this._state = Pump.STARTED;\n      this._pump();\n      return this;\n    };\n\n    Pump.prototype.whenFinished = function() {\n      if (this.isEnded()) {\n        return Promise.resolve();\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          _this.on('end', function() {\n            return resolve();\n          });\n          return _this.on('error', function() {\n            return reject(new PumpingFailedError());\n          });\n        };\n      })(this));\n    };\n\n    Pump.prototype.logErrorsToConsole = function() {\n      this.errorBuffer().on('write', (function(_this) {\n        return function(errorRecord) {\n          var name, _ref, _ref1;\n          name = (_ref = errorRecord.pump) != null ? _ref : '(root)';\n          if (_this._debug) {\n            console.log(\"Error in pump \" + name + \":\");\n            return console.log((_ref1 = errorRecord.error.stack) != null ? _ref1 : errorRecord.error);\n          } else {\n            return console.log(\"Error in pump \" + name + \": \" + errorRecord.error);\n          }\n        };\n      })(this));\n      return this;\n    };\n\n    Pump.prototype.logErrorsToLogger = function(logger) {\n      if (!((logger != null ? logger.error : void 0) instanceof Function)) {\n        throw new Error('logger must have an .error() method');\n      }\n      this.errorBuffer().on('write', (function(_this) {\n        return function(errorRecord) {\n          var name, _ref, _ref1;\n          name = (_ref = errorRecord.pump) != null ? _ref : '(root)';\n          if (_this._debug) {\n            logger.error(\"Error in pump \" + name + \":\");\n            return logger.error((_ref1 = errorRecord.error.stack) != null ? _ref1 : errorRecord.error);\n          } else {\n            return logger.error(\"Error in pump \" + name + \": \" + errorRecord.error);\n          }\n        };\n      })(this));\n      return this;\n    };\n\n    Pump.prototype.debug = function() {\n      this.debugMode(true);\n      return this;\n    };\n\n    Pump.prototype.debugMode = function(_debug) {\n      this._debug = _debug;\n      if (this._state !== Pump.STOPPED) {\n        throw new Error('Cannot change debug mode after pump start');\n      }\n      if (this._debug) {\n        this.mixin(BufferDebugMixin);\n      }\n      return this;\n    };\n\n    Pump.prototype.run = function() {\n      return this.start().whenFinished();\n    };\n\n    return Pump;\n\n  })(EventEmitter);\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/Buffer.js":"(function() {\n  var Buffer, EventEmitter, Promise,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  EventEmitter = require('events').EventEmitter;\n\n  Promise = require('bluebird');\n\n  Buffer = (function(_super) {\n    __extends(Buffer, _super);\n\n    Buffer._defaultBufferSize = 10;\n\n    Buffer.defaultBufferSize = function(size) {\n      if (size == null) {\n        return Buffer._defaultBufferSize;\n      }\n      return Buffer._defaultBufferSize = size;\n    };\n\n    function Buffer(options) {\n      var _ref, _ref1, _ref2;\n      if (options == null) {\n        options = {};\n      }\n      this.content = (_ref = options.content) != null ? _ref : [];\n      this.size = (_ref1 = options.size) != null ? _ref1 : Buffer._defaultBufferSize;\n      this._sealed = (_ref2 = options.sealed) != null ? _ref2 : false;\n    }\n\n    Buffer.prototype.isEmpty = function() {\n      return this.content.length === 0;\n    };\n\n    Buffer.prototype.isFull = function() {\n      return this.content.length >= this.size;\n    };\n\n    Buffer.prototype.getContent = function() {\n      return this.content;\n    };\n\n    Buffer.prototype.write = function(data) {\n      if (this._sealed === true) {\n        throw new Error('Cannot write sealed buffer');\n      }\n      if (this.isFull()) {\n        throw new Error('Buffer is full');\n      }\n      this.content.push(data);\n      this.emit('write', data);\n      if (this.isFull()) {\n        this.emit('full');\n      }\n      return this;\n    };\n\n    Buffer.prototype.append = function(data) {\n      this.appendArray([data]);\n      return this;\n    };\n\n    Buffer.prototype.appendArray = function(dataArray) {\n      var data, newSize, _i, _len;\n      newSize = this.content.length + dataArray.length;\n      if (newSize > this.size) {\n        this.size = newSize;\n      }\n      for (_i = 0, _len = dataArray.length; _i < _len; _i++) {\n        data = dataArray[_i];\n        this.write(data);\n      }\n      return this;\n    };\n\n    Buffer.prototype.writeAsync = function(data) {\n      if (!this.isFull()) {\n        return Promise.resolve(this.write(data));\n      } else {\n        return new Promise((function(_this) {\n          return function(resolve, reject) {\n            return _this.once('release', function() {\n              return resolve(_this.writeAsync(data));\n            });\n          };\n        })(this));\n      }\n    };\n\n    Buffer.prototype.writeArrayAsync = function(dataArray) {\n      var result;\n      if (dataArray.length === 0) {\n        return Promise.resolve();\n      }\n      result = Promise.pending();\n      this._writeArrayItem(dataArray, result, 0);\n      return result.promise;\n    };\n\n    Buffer.prototype._writeArrayItem = function(dataArray, pendingPromise, index) {\n      return this.writeAsync(dataArray[index]).done((function(_this) {\n        return function() {\n          if (index >= dataArray.length - 1) {\n            return pendingPromise.resolve();\n          }\n          return _this._writeArrayItem(dataArray, pendingPromise, index + 1);\n        };\n      })(this));\n    };\n\n    Buffer.prototype.read = function() {\n      var result;\n      if (this.isEmpty()) {\n        throw new Error('Buffer is empty');\n      }\n      result = this.content.shift();\n      this.emit('release', result);\n      if (this.isEmpty()) {\n        this.emit('empty');\n        if (this._sealed === true) {\n          this.emit('end');\n        }\n      }\n      return result;\n    };\n\n    Buffer.prototype.readAsync = function() {\n      if (!this.isEmpty()) {\n        return Promise.resolve(this.read());\n      } else {\n        return new Promise((function(_this) {\n          return function(resolve, reject) {\n            return _this.once('write', function() {\n              return resolve(_this.readAsync());\n            });\n          };\n        })(this));\n      }\n    };\n\n    Buffer.prototype.seal = function() {\n      if (this._sealed === true) {\n        throw new Error('Buffer already sealed');\n      }\n      this._sealed = true;\n      this.emit('sealed');\n      if (this.isEmpty()) {\n        this.emit('end');\n      }\n      return this;\n    };\n\n    Buffer.prototype.isSealed = function() {\n      return this._sealed === true;\n    };\n\n    Buffer.prototype.isEnded = function() {\n      return this.isSealed() && this.isEmpty();\n    };\n\n    return Buffer;\n\n  })(EventEmitter);\n\n  module.exports = Buffer;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/PumpingFailedError.js":"(function() {\n  var PumpingFailedError,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  module.exports = PumpingFailedError = (function(_super) {\n    __extends(PumpingFailedError, _super);\n\n    PumpingFailedError.prototype.name = 'PumpingFailedError';\n\n    function PumpingFailedError(message) {\n      this.message = message != null ? message : 'Pumping failed. See .errorBuffer() contents for error messages';\n      PumpingFailedError.__super__.constructor.call(this, this.message);\n    }\n\n    return PumpingFailedError;\n\n  })(Error);\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/BufferDebugMixin.js":"(function() {\n  module.exports = function(pump) {\n    var clearBufferStats, collectBuffers, delay, dumpStats, dumpStatsIfNotEnded, hadTraffic, listenToBuffersEvents, monitorBuffers, _bufferStats, _start;\n    if ('_bufferDebugMixin' in pump) {\n      return;\n    }\n    _start = pump.start;\n    _bufferStats = {};\n    pump._bufferDebugMixin = {\n      version: 1\n    };\n    pump.start = function() {\n      _start.call(pump);\n      if (this._debug !== true) {\n        return this;\n      }\n      collectBuffers();\n      listenToBuffersEvents();\n      monitorBuffers();\n      pump.whenFinished().then(function() {\n        return dumpStats();\n      });\n      return this;\n    };\n    collectBuffers = function() {\n      var buffer, name, _ref;\n      _bufferStats = {\n        input: {\n          buffer: pump.from()\n        }\n      };\n      _ref = pump.buffers();\n      for (name in _ref) {\n        buffer = _ref[name];\n        _bufferStats[name] = {\n          buffer: buffer\n        };\n      }\n      return clearBufferStats();\n    };\n    clearBufferStats = function() {\n      var buffer, name, _results;\n      _results = [];\n      for (name in _bufferStats) {\n        buffer = _bufferStats[name];\n        buffer.releases = 0;\n        _results.push(buffer.writes = 0);\n      }\n      return _results;\n    };\n    listenToBuffersEvents = function() {\n      var buffer, name, _results;\n      _results = [];\n      for (name in _bufferStats) {\n        buffer = _bufferStats[name];\n        _results.push((function(buffer) {\n          if (!buffer.buffer) {\n            return;\n          }\n          buffer.buffer.on('write', function() {\n            return buffer.writes++;\n          });\n          return buffer.buffer.on('release', function() {\n            return buffer.releases++;\n          });\n        })(buffer));\n      }\n      return _results;\n    };\n    monitorBuffers = function() {\n      return delay(1000, function() {\n        dumpStatsIfNotEnded();\n        clearBufferStats();\n        if (!pump.isEnded()) {\n          return monitorBuffers();\n        }\n      });\n    };\n    delay = function(ms, func) {\n      return setTimeout(func, ms);\n    };\n    dumpStatsIfNotEnded = function() {\n      if (pump.isEnded()) {\n        return;\n      }\n      return dumpStats();\n    };\n    dumpStats = function() {\n      var buffer, name, _ref;\n      if (!hadTraffic()) {\n        return;\n      }\n      process.stdout.write(\"\" + ((new Date()).toISOString()) + \" [\" + ((_ref = pump.id()) != null ? _ref : '(root)') + \"] \");\n      for (name in _bufferStats) {\n        buffer = _bufferStats[name];\n        process.stdout.write(\"\" + name + \": \" + (buffer.buffer.getContent().length) + \" items, \" + buffer.writes + \" in, \" + buffer.releases + \" out | \");\n      }\n      return process.stdout.write(\"\\n\");\n    };\n    return hadTraffic = function() {\n      var buffer, name;\n      for (name in _bufferStats) {\n        buffer = _bufferStats[name];\n        if (buffer.releases > 0 || buffer.writes > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/index.js":"(function() {\n  module.exports = {\n    ObjectTransformMixin: require('./ObjectTransformMixin'),\n    BatchMixin: require('./BatchMixin'),\n    MergeMixin: require('./MergeMixin'),\n    CsvWriterMixin: require('./CsvWriterMixin'),\n    ExcelReaderMixin: require('./ExcelReaderMixin'),\n    ExcelWriterMixin: require('./ExcelWriterMixin'),\n    MysqlMixin: require('./MysqlMixin'),\n    MongodbMixin: require('./MongodbMixin'),\n    RestMixin: require('./RestMixin'),\n    BufferDebugMixin: require('./BufferDebugMixin'),\n    PostgresqlMixin: require('./PostgresqlMixin')\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/ObjectTransformMixin.js":"(function() {\n  var objectTransformMixin;\n\n  objectTransformMixin = function() {\n    return function(target) {\n      target.propertiesToLowerCase = function(data) {\n        var prop, result, value;\n        result = {};\n        for (prop in data) {\n          value = data[prop];\n          result[prop.toLowerCase()] = value;\n        }\n        return result;\n      };\n      target.requireProperty = function(obj, properties) {\n        var property, result, _i, _j, _len, _len1;\n        properties = Array.isArray(properties) ? properties : [properties];\n        for (_i = 0, _len = properties.length; _i < _len; _i++) {\n          property = properties[_i];\n          if (obj[property] == null) {\n            throw new Error('Missing property: ' + property);\n          }\n        }\n        if (properties.length === 1) {\n          return obj[properties[0]];\n        } else {\n          result = {};\n          for (_j = 0, _len1 = properties.length; _j < _len1; _j++) {\n            property = properties[_j];\n            result[property] = obj[property];\n          }\n          return result;\n        }\n      };\n      return target.boolValueOf = function(obj) {\n        return !(obj === null || obj === void 0 || obj === false || obj === 'off' || obj === 'false' || obj === 0 || obj === 'no');\n      };\n    };\n  };\n\n  module.exports = objectTransformMixin;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/BatchMixin.js":"(function() {\n  var BatchProcessMixin, Promise;\n\n  Promise = require('bluebird');\n\n  module.exports = BatchProcessMixin = function(target) {\n    var pumpMethod;\n    target._batchSize = 100;\n    target._batch = [];\n    target.batchSize = function(size) {\n      if (size == null) {\n        return this._batchSize;\n      }\n      if (size <= 1) {\n        throw new Error(\"Invalid batch size: \" + size);\n      }\n      this._batchSize = size;\n      return this;\n    };\n    target.processBatch = function(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error('processBatch argument must be a function');\n      }\n      this._processBatch = fn;\n      return this;\n    };\n    target._process = function(data) {\n      var result;\n      this._batch.push(data);\n      if (this._batch.length >= this._batchSize) {\n        result = this._processBatch(this._batch);\n        this._batch = [];\n        return result;\n      } else {\n        return Promise.resolve();\n      }\n    };\n    pumpMethod = target._pump;\n    return target._pump = function() {\n      if (this._from.isEnded()) {\n        if (this._batch.length > 0) {\n          Promise.resolve(this._processBatch(this._batch))[\"catch\"]((function(_this) {\n            return function(err) {\n              return _this.writeError(err);\n            };\n          })(this)).then((function(_this) {\n            return function() {\n              return _this.sealOutputBuffers();\n            };\n          })(this));\n        } else {\n          this.sealOutputBuffers();\n        }\n        this._batch = [];\n        return;\n      }\n      return pumpMethod.apply(target, []);\n    };\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/MergeMixin.js":"(function() {\n  var Buffer, MergeHelperPump, MergeMixin, Pump,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Pump = require('../Pump');\n\n  Buffer = require('../Buffer');\n\n  MergeHelperPump = (function(_super) {\n    __extends(MergeHelperPump, _super);\n\n    function MergeHelperPump() {\n      return MergeHelperPump.__super__.constructor.apply(this, arguments);\n    }\n\n    MergeHelperPump.prototype.sealOutputBuffers = function() {\n      return this.emit('sealOutput');\n    };\n\n    return MergeHelperPump;\n\n  })(Pump);\n\n  module.exports = MergeMixin = function(pump) {\n    pump.from(new Buffer());\n    pump._fromBuffers = [];\n    return pump.from = function(buffer) {\n      var helperPump, sourceBuffer;\n      if (buffer == null) {\n        buffer = null;\n      }\n      if (buffer === null) {\n        return this._from;\n      }\n      if (this._state === Pump.STARTED) {\n        throw new Error('Cannot change source buffer after pumping has been started');\n      }\n      if (buffer instanceof Buffer) {\n        sourceBuffer = buffer;\n      } else if (buffer instanceof Pump) {\n        sourceBuffer = buffer.buffer();\n      } else if (buffer instanceof require('stream')) {\n        sourceBuffer = new Buffer({\n          size: 1000\n        });\n        buffer.on('data', (function(_this) {\n          return function(data) {\n            return sourceBuffer.write(data);\n          };\n        })(this));\n        buffer.on('end', (function(_this) {\n          return function() {\n            return sourceBuffer.seal();\n          };\n        })(this));\n        buffer.on('error', (function(_this) {\n          return function(err) {\n            return _this.writeError(err);\n          };\n        })(this));\n        sourceBuffer.on('full', function() {\n          return buffer.pause();\n        });\n        sourceBuffer.on('release', function() {\n          return buffer.resume();\n        });\n      } else {\n        throw new Error('Argument must be datapumps.Buffer or stream');\n      }\n      this._fromBuffers.push(sourceBuffer);\n      (helperPump = new MergeHelperPump()).from(sourceBuffer).buffer('output', this._from).process(function(data) {\n        return this.copy(data);\n      });\n      helperPump.on('sealOutput', function() {\n        var allEnded, _i, _len, _ref;\n        allEnded = true;\n        _ref = pump._fromBuffers;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          buffer = _ref[_i];\n          if (!buffer.isEnded()) {\n            allEnded = false;\n          }\n        }\n        if (!allEnded) {\n          return;\n        }\n        if (!pump._from.isSealed()) {\n          return pump._from.seal();\n        }\n      }).start();\n      return this;\n    };\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/CsvWriterMixin.js":"(function() {\n  var CsvWriterMixin, Promise, csv, fs;\n\n  csv = require('fast-csv');\n\n  fs = require('fs');\n\n  Promise = require('bluebird');\n\n  CsvWriterMixin = function(options) {\n    if (!(options != null ? options.path : void 0)) {\n      throw new Error('path option is required.');\n    }\n    return function(target) {\n      target.writeRow = function(row) {\n        return target._csv.writer.writeAsync(row);\n      };\n      target._csv = options;\n      target._csv.writer = Promise.promisifyAll(csv.createWriteStream());\n      target._csv.writer.pipe(fs.createWriteStream(target._csv.path, {\n        encoding: 'utf8'\n      }));\n      if (target._csv.headers != null) {\n        target.writeRow(target._csv.headers);\n      }\n      return target.on('end', function() {\n        return target._csv.writer.write(null);\n      });\n    };\n  };\n\n  module.exports = CsvWriterMixin;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/ExcelReaderMixin.js":"(function() {\n  var Buffer, ExcelReaderMixin, convertSheetToJson, readFile, _ref, _ref1;\n\n  _ref = require('xlsx'), readFile = _ref.readFile, (_ref1 = _ref.utils, convertSheetToJson = _ref1.sheet_to_json);\n\n  Buffer = require('../Buffer');\n\n  ExcelReaderMixin = function(_arg) {\n    var columnMapping, path, worksheet;\n    worksheet = _arg.worksheet, columnMapping = _arg.columnMapping, path = _arg.path;\n    return function(target) {\n      var buffer, content, data, mapColumnNames, workbook, _i, _len, _ref2;\n      if (path != null) {\n        workbook = readFile(path);\n        worksheet = workbook.Sheets[worksheet];\n      }\n      if (worksheet == null) {\n        throw new Error('worksheet property is required for ExcelReaderMixin');\n      }\n      target._excel = {\n        worksheet: worksheet,\n        columnMapping: columnMapping\n      };\n      mapColumnNames = function(data) {\n        var from, result, to;\n        result = {};\n        for (from in columnMapping) {\n          to = columnMapping[from];\n          result[to] = data[from];\n        }\n        return result;\n      };\n      content = [];\n      if (columnMapping) {\n        _ref2 = convertSheetToJson(worksheet);\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          data = _ref2[_i];\n          content.push(mapColumnNames(data));\n        }\n      } else {\n        content = convertSheetToJson(worksheet);\n      }\n      buffer = new Buffer({\n        content: content\n      });\n      target.from(buffer);\n      return buffer.seal();\n    };\n  };\n\n  module.exports = ExcelReaderMixin;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/ExcelWriterMixin.js":"(function() {\n  var ExcelWriterMixin, Promise, excel4node;\n\n  excel4node = require('excel4node');\n\n  Promise = require('bluebird');\n\n  ExcelWriterMixin = function(onMixin) {\n    return function(target) {\n      target._excel = {\n        columnTypes: [],\n        path: null\n      };\n      target.createWorkbook = function(path) {\n        if (this._excel.workbook != null) {\n          throw new Error('Workbook already created');\n        }\n        this.workbook(new excel4node.WorkBook());\n        this._excel.path = path;\n        this.on('end', (function(_this) {\n          return function() {\n            return _this._excel.workbook.write(_this._excel.path);\n          };\n        })(this));\n        this._excel.workbook;\n        return this;\n      };\n      target.workbook = function(workbook) {\n        if (workbook == null) {\n          workbook = null;\n        }\n        if (workbook === null) {\n          return this._excel.workbook;\n        }\n        this._excel.workbook = workbook;\n        this._excel.boldStyle = this._excel.workbook.Style();\n        this._excel.boldStyle.Font.Bold();\n        return this;\n      };\n      target.createWorksheet = function(name) {\n        if (this._excel.workbook == null) {\n          throw new Error('Use createWorkbook before creating worksheet');\n        }\n        this._excel.worksheet = this._excel.workbook.WorkSheet(name);\n        this._excel.currentRow = 1;\n        return this;\n      };\n      target.currentWorksheet = function() {\n        return this._excel.worksheet;\n      };\n      target.writeHeaders = function(headers, types) {\n        var header, index, _i, _len, _ref;\n        if (types == null) {\n          types = [];\n        }\n        if (this._excel.worksheet == null) {\n          throw new Error('Use createWorksheet before writing headers');\n        }\n        if (this._excel.currentRow !== 1) {\n          throw new Error('Use writeHeaders before writing any rows to the worksheet');\n        }\n        for (index = _i = 0, _len = headers.length; _i < _len; index = ++_i) {\n          header = headers[index];\n          this._writeHeader(index, header);\n          this.columnType(index, (_ref = types[index]) != null ? _ref : 'String');\n        }\n        this._excel.currentRow = 2;\n        return this;\n      };\n      target._writeHeader = function(index, header) {\n        this._excel.worksheet.Cell(1, index + 1).String(header).Style(this._excel.boldStyle);\n        return this;\n      };\n      target.columnType = function(index, type) {\n        if (type == null) {\n          type = null;\n        }\n        if (type === null) {\n          return this._excel.columnTypes[index];\n        }\n        if (['String', 'Number', 'Formula'].indexOf(type) === -1) {\n          throw new Error(\"Invalid column type '\" + type + \"'. Only String, Number or Formula is allowed\");\n        }\n        this._excel.columnTypes[index] = type;\n        return this;\n      };\n      target.writeRow = function(columns) {\n        var cell, index, value, _i, _len, _ref;\n        if (this._excel.worksheet == null) {\n          throw new Error('Use createWorksheet before writing rows');\n        }\n        for (index = _i = 0, _len = columns.length; _i < _len; index = ++_i) {\n          value = columns[index];\n          if (value === null || value === void 0) {\n            continue;\n          }\n          cell = this._excel.worksheet.Cell(this._excel.currentRow, index + 1);\n          cell[(_ref = this._excel.columnTypes[index]) != null ? _ref : 'String'](value);\n        }\n        this._excel.currentRow++;\n        return Promise.resolve();\n      };\n      if (onMixin) {\n        return onMixin.apply(target, [target]);\n      }\n    };\n  };\n\n  module.exports = ExcelWriterMixin;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/MysqlMixin.js":"(function() {\n  var Promise, mysqlMixin,\n    __slice = [].slice;\n\n  Promise = require('bluebird');\n\n  mysqlMixin = function(connection) {\n    if ((connection == null) || typeof (connection != null ? connection.query : void 0) !== 'function') {\n      throw new Error('Mysql mixin requires connection to be given');\n    }\n    return function(target) {\n      target._mysql = {\n        connection: connection,\n        query: Promise.promisify(connection.query, connection)\n      };\n      target.query = function() {\n        var args, query;\n        query = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        if (args != null) {\n          return this._mysql.query(query, args);\n        } else {\n          return this._mysql.query(query);\n        }\n      };\n      target.selectOne = function() {\n        var args, query;\n        query = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        return target.query(query, args).then(function(_arg) {\n          var fields, results;\n          results = _arg[0], fields = _arg[1];\n          if (results.length === 1) {\n            return results[0];\n          } else if (results.length === 0) {\n            throw new Error('Query returned no result');\n          } else {\n            throw new Error('Query returned more than one result');\n          }\n        });\n      };\n      return target.escape = function(value) {\n        return this._mysql.connection.escape(value);\n      };\n    };\n  };\n\n  module.exports = mysqlMixin;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/MongodbMixin.js":"(function() {\n  var PassThrough, Promise, mongo, _deferCollectionMethod, _deferFind, _wrapFind, _wrapMethod, _wrappedMethods,\n    __slice = [].slice;\n\n  Promise = require('bluebird');\n\n  mongo = Promise.promisifyAll(require('mongodb'));\n\n  PassThrough = require('stream').PassThrough;\n\n  module.exports = function(db) {\n    return function(target) {\n      var name, _i, _len;\n      target._mongo = {\n        db: db\n      };\n      if (typeof db === 'string') {\n        (target._mongo.whenConnected = mongo.MongoClient.connectAsync(db)).then(function(db) {\n          var _ref, _ref1;\n          target._mongo.db = db;\n          target.whenFinished().then(function() {\n            return target._mongo.db.close();\n          });\n          if (((_ref = target._mongo) != null ? (_ref1 = _ref.collection) != null ? _ref1._datapumpsMixinName : void 0 : void 0) != null) {\n            return target._mongo.collection = db.collection(target._mongo.collection._datapumpsMixinName);\n          }\n        });\n      }\n      for (_i = 0, _len = _wrappedMethods.length; _i < _len; _i++) {\n        name = _wrappedMethods[_i];\n        _wrapMethod(target, name);\n      }\n      _wrapFind(target);\n      target.setGlobalDefaultMaxBsonSize = function(size) {\n        require('mongodb').Connection.DEFAULT_MAX_BSON_SIZE = size;\n        require('mongodb').Connection.DEFAULT_MAX_MESSAGE_SIZE = size;\n        return this;\n      };\n      target.db = function() {\n        return this._mongo.db;\n      };\n      target.useCollection = function(name) {\n        var _j, _len1, _ref;\n        if ((target._mongo.whenConnected != null) && ((_ref = target._mongo) != null ? _ref.whenConnected.isPending() : void 0)) {\n          this._mongo.collection = {\n            _datapumpsMixinName: name\n          };\n          for (_j = 0, _len1 = _wrappedMethods.length; _j < _len1; _j++) {\n            name = _wrappedMethods[_j];\n            _deferCollectionMethod(this._mongo.collection, name + 'Async', this);\n          }\n          _deferFind(this._mongo.collection, this);\n        } else {\n          this._mongo.collection = this._mongo.db.collection(name);\n        }\n        return this;\n      };\n      return target.collection = function(name) {\n        var _ref;\n        if ((_ref = target._mongo) != null ? _ref.whenConnected.isPending() : void 0) {\n          throw new Error('Not yet connected to mongo');\n        }\n        return this._mongo.db.collection(name);\n      };\n    };\n  };\n\n  _wrappedMethods = ['insert', 'remove', 'rename', 'save', 'update', 'count', 'drop', 'findOne', 'createIndex', 'ensureIndex', 'dropIndex', 'reIndex', 'group', 'options', 'indexes', 'stats', 'findAndModify', 'findAndRemove'];\n\n  _wrapMethod = function(target, name) {\n    return target[name] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (this._mongo.collection == null) {\n        throw new Error('Collection is not set. Use .useCollection before using this wrapper');\n      }\n      if (!this._mongo.collection[name + 'Async']) {\n        throw new Error(\"Method .\" + name + \"Async() does not exist in collection.\");\n      }\n      return this._mongo.collection[name + 'Async'].apply(this._mongo.collection, args);\n    };\n  };\n\n  _wrapFind = function(target) {\n    return target.find = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (this._mongo.collection == null) {\n        throw new Error('Collection is not set. Use .useCollection before using this wrapper');\n      }\n      if (!this._mongo.collection.find) {\n        throw new Error(\"Method .find() does not exist in collection.\");\n      }\n      return this._mongo.collection.find.apply(this._mongo.collection, args).stream();\n    };\n  };\n\n  _deferCollectionMethod = function(collection, name, target) {\n    return collection[name] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return target._mongo.whenConnected.then(function() {\n        if (!target._mongo.collection[name]) {\n          throw new Error(\"Method .\" + name + \" does not exist in collection.\");\n        }\n        return target._mongo.collection[name].apply(target._mongo.collection, args);\n      });\n    };\n  };\n\n  _deferFind = function(collection, target) {\n    return collection.find = function() {\n      var args, result;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      result = new PassThrough({\n        objectMode: true,\n        highWaterMark: 10\n      });\n      target._mongo.whenConnected.then(function() {\n        return target._mongo.collection.find.apply(target._mongo.collection, args).stream().pipe(result);\n      });\n      return {\n        stream: function() {\n          return result;\n        }\n      };\n    };\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/RestMixin.js":"(function() {\n  var Promise, RestMixin, restler, _wrapMethod;\n\n  Promise = require('bluebird');\n\n  restler = require('restler');\n\n  module.exports = RestMixin = function(target) {\n    _wrapMethod(target, 'get');\n    _wrapMethod(target, 'post');\n    _wrapMethod(target, 'put');\n    _wrapMethod(target, 'del');\n    _wrapMethod(target, 'head');\n    _wrapMethod(target, 'patch');\n    _wrapMethod(target, 'json');\n    _wrapMethod(target, 'postJson');\n    _wrapMethod(target, 'putJson');\n    target.file = function() {\n      return restler.file.apply(restler, arguments);\n    };\n    return target.fromRest = function(config) {\n      var queryAndWriteInputBuffer;\n      if (!(config != null ? config.query : void 0)) {\n        throw new Error('query key is required');\n      }\n      if (config.resultMapping == null) {\n        config.resultMapping = function(result) {\n          return result;\n        };\n      }\n      if (config.nextPage == null) {\n        config.nextPage = function() {\n          return void 0;\n        };\n      }\n      this.from(this.createBuffer());\n      queryAndWriteInputBuffer = (function(_this) {\n        return function(nextPage) {\n          return config.query.apply(_this, [nextPage]).then(function(response) {\n            return _this.from().writeArrayAsync(config.resultMapping(response)).done(function() {\n              nextPage = config.nextPage(response);\n              if ((nextPage === void 0) || (nextPage === null)) {\n                return _this.from().seal();\n              } else {\n                return queryAndWriteInputBuffer(nextPage);\n              }\n            });\n          });\n        };\n      })(this);\n      queryAndWriteInputBuffer(void 0);\n      return this;\n    };\n  };\n\n  _wrapMethod = function(target, methodName) {\n    return target[methodName] = function() {\n      var methodArgs;\n      methodArgs = arguments;\n      return new Promise(function(resolve, reject) {\n        return restler[methodName].apply(restler, methodArgs).on('complete', function(result, response) {\n          if (result instanceof Error) {\n            return reject(result);\n          } else {\n            response.result = result;\n            return resolve(response);\n          }\n        });\n      });\n    };\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-datapumps/node_modules/datapumps/lib/mixin/PostgresqlMixin.js":"(function() {\n  var postgresqlMixin,\n    __slice = [].slice;\n\n  postgresqlMixin = function(client) {\n    if ((client == null) || typeof (client != null ? client.query : void 0) !== 'function') {\n      throw new Error('Postgresql mixin requires client to be given');\n    }\n    return function(target) {\n      target.query = function() {\n        var args, query;\n        query = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        if (args != null) {\n          return client.query(query, args);\n        } else {\n          return client.query(query);\n        }\n      };\n      return target.selectOne = function() {\n        var args, query;\n        query = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        return target.query(query, args).then(function(_arg) {\n          var fields, results;\n          results = _arg[0], fields = _arg[1];\n          if (results.length === 1) {\n            return results[0];\n          } else if (results.length === 0) {\n            throw new Error('Query returned no result');\n          } else {\n            throw new Error('Query returned more than one result');\n          }\n        });\n      };\n    };\n  };\n\n  module.exports = postgresqlMixin;\n\n}).call(this);\n"}